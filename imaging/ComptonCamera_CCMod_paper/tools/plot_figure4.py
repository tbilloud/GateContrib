import os
import sys
import matplotlib
matplotlib.get_backend()
import matplotlib.pyplot as plt
import uproot
import pandas
import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning)
pandas.set_option('display.max_columns', 20), pandas.set_option('display.width', 400)

path = '../output/seed1_time100/CC_Coincidences.root'
bins = 300

tree = uproot.open(os.path.abspath(path) + ':Coincidences')
print(tree.num_entries, 'entries in tree Coincidences')
df = tree.arrays(['eventID', 'coincID', 'layerName', 'energy'], '(energy>0)', library='pd')
df_grouped_by_coincID = df.groupby('coincID')
coincSize = df_grouped_by_coincID.size()
for i in range(2, coincSize.max() + 1):
    print('number of coincidences with', i, 'singles:', len(coincSize[coincSize == i]), '(from different events/decays)' if i>2 else '')

# Most of the coincidences have one single per layer, since the adder sums up all hits in the same layer for each event.
# However, it can be more because events/decays can overlap. This is noted in the paper:
#   'The studied experimental data were taken with a 22Na source which leads to several photons per decay (511 keV and
#   1275 keV). Therefore, the information of the primary photon that produces each interaction, included in the CCMod,
#   was employed to distinguish between random coincidences generated by the detection of different photons coming from
#   the same decay process'
# => Here I reject overlapping events/decays:
df_filtered = df.groupby('eventID').filter(lambda x: len(x) == 2)
df1 = df_filtered[df_filtered['layerName'] == 'scatterer_phys'].reset_index(drop=True)
df2 = df_filtered[df_filtered['layerName'] == 'absorber_phys'].reset_index(drop=True)
e1 = df1['energy']
e2 = df2['energy']
if len(e1) != len(e2):
    sys.exit('PROBLEM: different number of singles in the layers:', len(e1), len(e2))
esum = e1 + e2

# Plot
fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(25, 5))
plot_args = dict(bins=bins, histtype='step', color='black', linestyle='dotted' )
ax1.hist(1000 * e1, range=(0, 1400), **plot_args)
ax1.set_title('first layer', y=-0.15)
ax1.set_xlabel('E1 (keV)', loc='right')
ax1.set_ylabel('Counts')
ax1.set_xlim(xmin=0, xmax=1400)
ax2.hist(1000 * e2, range=(0, 1400), **plot_args)
ax2.set_title('second layer', y=-0.15)
ax2.set_xlabel('E2 (keV)', loc='right')
ax2.set_ylabel('Counts')
ax2.set_xlim(xmin=0, xmax=1400)
ax3.hist(1000 * esum, range=(0, 2000), **plot_args)
ax3.set_title('sum', y=-0.15)
ax3.set_xlabel('E_sum (keV)', loc='right')
ax3.set_ylabel('Counts')
ax3.set_xlim(xmin=0, xmax=2000)
plt.tight_layout()
plt.show()
